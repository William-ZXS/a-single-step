#	如何查看properties.yml文件中的可配置项

每一组可配置的都会对应一个Properties类

你按照那个第三方包的名字加上Properties搜一下类名看能不能搜到，一般命名规则是这样的，在它的Properties类里定义了所有它的可配置项







@Transactional事务几点注意
这里面有几点需要大家留意：
A. 一个功能是否要事务，必须纳入设计、编码考虑。不能仅仅完成了基本功能就ok。
B. 如果加了事务，必须做好开发环境测试（测试环境也尽量触发异常、测试回滚），确保事务生效。
C. 以下列了事务使用过程的注意事项，请大家留意。

1.不要在接口上声明@Transactional ，而要在具体类的方法上使用 @Transactional 注解，否则注解可能无效。

2.不要图省事，将@Transactional放置在类级的声明中，放在类声明，会使得所有方法都有事务。故@Transactional应该放在方法级别，不需要使用事务的方法，就不要放置事务，比如查询方法。否则对性能是有影响的。

3.使用了@Transactional的方法，对同一个类里面的方法调用， @Transactional无效。比如有一个类Test，它的一个方法A，A再调用Test本类的方法B（不管B是否public还是private），但A没有声明注解事务，而B有。则外部调用A之后，B的事务是不会起作用的。（经常在这里出错）

4.使用了@Transactional的方法，只能是public，@Transactional注解的方法都是被外部其他类调用才有效，故只能是public。道理和上面的有关联。故在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错，但事务无效。

5.spring的事务在抛异常的时候会回滚，如果是catch捕获了，事务无效。可以在catch里面加上throw new RuntimeException();

6.最后有个关键的一点：和锁同时使用需要注意：由于Spring事务是通过AOP实现的，所以在方法执行之前会有开启事务，之后会有提交事务逻辑。而synchronized代码块执行是在事务之内执行的，可以推断在synchronized代码块执行完时，事务还未提交，其他线程进入synchronized代码块后，读取的数据不是最新的。
所以必须使synchronized锁的范围大于事务控制的范围，把synchronized加到Controller层或者大于事务边界的调用层！





# fastjson

JSONObject转java对象

```
JSON.toJavaObject(data,RespAggrePrint.class)
```







# Array.asList

比较两者的不同

```
int[] aa = {1,2,3,4,5};
System.out.println(aa);
System.out.println(Arrays.asList(aa));
System.out.println(Arrays.asList(aa).contains(2));

List<Integer> mm = Arrays.asList(1, 2, 3, 4, 5, 6);
System.out.println(mm);
System.out.println(mm.contains(2));
```



# 运算

将浮点数转化成字符串的小技巧(**拼接字符串**)

```
"" + 2.5

"1" + 2.5  
>> 12.5
```



# Java 8 Stream
迭代器是遍历策略，同时阻止了并发执行

Stream 使用的得当效率会有很大的提升，可以多线程执行任务。

简单场景下未必有for循环速度快，因为不用调用过多的资源。

# Spring Reactor
如果将迭代器看作是拉模式，那观测者模式便是推模式

# 函数试编程
**特性**
* 将函数作为参数传递给另外一个参数
* 函数可以作为另外一个函数的返回值
* 函数试编程是申明式的编程方式。

FunctionalInterface

# Java 8
## interface
interface 可以使用default 写实现的方法。当继承的两个interface都实现了某个方法时就会出错，需要重写方法（重写也可以调用父辈的方法）

## 方法引用
```
System.out::println
```


## completableFuture

## Runnable


# java concurrent

**问题：核心线程池的大小配置多少合适？**

这个问题经过各位前辈大佬的各种测试，总结出来如下两条经验：

* IO密集型任务：2*CPU数，因为IO密集型任务，线程不是一直在运行，所以可以配置多一点；
* CPU密集型任务：因为一直在使用CPU，所以要保证线程数不能太多，可以CPU数+1；

# class && method
静态方法与实例方法的区别：

* 静态方法：静态方法会随着类的定义而被分配和装载入内存中。静态方法可以调用静态方法以及访问静态数据域，但静态方法不能调用实例方法或者访问实例数据域。

* 实例方法：只有在类的对象创建时在对象的内存中才有这个方法的代码段。实例方法可以调用实例方法和静态方法，以及访问实例数据域或者静态数据域。

静态方法在内存中只会有一份，会比较省内存。

# SimpleDateFormat
SimpleDateFormat 线程不安全