#	如何查看properties.yml文件中的可配置项

每一组可配置的都会对应一个Properties类

你按照那个第三方包的名字加上Properties搜一下类名看能不能搜到，一般命名规则是这样的，在它的Properties类里定义了所有它的可配置项







@Transactional事务几点注意
这里面有几点需要大家留意：
A. 一个功能是否要事务，必须纳入设计、编码考虑。不能仅仅完成了基本功能就ok。
B. 如果加了事务，必须做好开发环境测试（测试环境也尽量触发异常、测试回滚），确保事务生效。
C. 以下列了事务使用过程的注意事项，请大家留意。

1.不要在接口上声明@Transactional ，而要在具体类的方法上使用 @Transactional 注解，否则注解可能无效。

2.不要图省事，将@Transactional放置在类级的声明中，放在类声明，会使得所有方法都有事务。故@Transactional应该放在方法级别，不需要使用事务的方法，就不要放置事务，比如查询方法。否则对性能是有影响的。

3.使用了@Transactional的方法，对同一个类里面的方法调用， @Transactional无效。比如有一个类Test，它的一个方法A，A再调用Test本类的方法B（不管B是否public还是private），但A没有声明注解事务，而B有。则外部调用A之后，B的事务是不会起作用的。（经常在这里出错）

4.使用了@Transactional的方法，只能是public，@Transactional注解的方法都是被外部其他类调用才有效，故只能是public。道理和上面的有关联。故在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错，但事务无效。

5.spring的事务在抛异常的时候会回滚，如果是catch捕获了，事务无效。可以在catch里面加上throw new RuntimeException();

6.最后有个关键的一点：和锁同时使用需要注意：由于Spring事务是通过AOP实现的，所以在方法执行之前会有开启事务，之后会有提交事务逻辑。而synchronized代码块执行是在事务之内执行的，可以推断在synchronized代码块执行完时，事务还未提交，其他线程进入synchronized代码块后，读取的数据不是最新的。
所以必须使synchronized锁的范围大于事务控制的范围，把synchronized加到Controller层或者大于事务边界的调用层！





# fastjson

JSONObject转java对象

```
JSON.toJavaObject(data,RespAggrePrint.class)
```







# Array.asList

比较两者的不同

```
int[] aa = {1,2,3,4,5};
System.out.println(aa);
System.out.println(Arrays.asList(aa));
System.out.println(Arrays.asList(aa).contains(2));

List<Integer> mm = Arrays.asList(1, 2, 3, 4, 5, 6);
System.out.println(mm);
System.out.println(mm.contains(2));
```



# 运算

将浮点数转化成字符串的小技巧(**拼接字符串**)

```
"" + 2.5

"1" + 2.5  
>> 12.5
```



# Java 8 Stream

Stream 使用的得当效率会有很大的提升，可以多线程执行任务。

简单场景下未必有for循环速度快，因为不用调用过多的资源。

# Spring Reactor
如果将迭代器看作是拉模式，那观测者模式便是推模式

