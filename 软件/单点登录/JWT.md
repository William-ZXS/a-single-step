`JWT` 顾名思义，它是 `JSON` 结构的 `token`，由三部分组成：

- **header**
- **payload**
- **signature**

#### header

`header` 用于描述 **元信息**，例如产生 `signature` 的算法：



```json
{    
    "typ": "JWT",
    "alg": "HS256"
}
```

其中 `alg` 关键字就指定了使用哪一种 **哈希算法** 来创建 `signature`。

#### payload

`payload` 用于携带你希望 **向服务端传递** 的信息。你既可以往里添加 **官方字段**，例如：`iss(Issuer)`, `sub(Subject)`, `exp(Expirationtime)`，也可以塞入 **自定义的字段**，比如 `userId`:



```json
{
    "userId": "b08f86af-35da-48f2-8fab-cef3904660bd"
}
```

#### signature

`signature` 译为 **签名**，创建签名要分以下几个步骤：

1. 从 **接口服务端** 拿到 **密钥**，假设为 `secret`。
2. 对 `header` 进行 `base64` 编码，假设结果为 `headerStr`。
3. 将 `payload` 进行 `base64` 编码，假设结果为 `payloadStr`。
4. 将 `headerStr` 和 `payloadStr` 用 `.` **字符** 拼装起来成为字符 `data`。
5. 以 `data` 和 `secret` 作为参数，使用 **哈希算法** 计算出 **签名**。

假设我们的原始 `JSON` 结构是这样的：



```json
// Header
{
    "typ": "JWT",
    "alg": "HS256"
}

// Payload
{
    "userId": "b08f86af-35da-48f2-8fab-cef3904660bd"
}
```



JWT结果示例：

```bash
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```





### JWT究竟带来了什么

#### 确保数据完整性

`JWT` 的目的不是为了 **隐藏** 或者 **保密数据**，而是为了确保 **数据** 确实来自被 **授权的人** 创建的，以防止 **中途篡改**。

回想一下，当你拿到 `JWT` 时候，你完全可以在没有 `secret` 的情况下解码出 `header` 和 `payload`，因为 `header` 和 `payload` 只是经过了 `base64` 编码（`encode`）而已，编码的目的在于 **利于数据结构的传输**。

虽然创建 `signature` 的过程近似于 **加密** (`encrypt`)，但本质其实是一种 **签名** (`sign`) 的行为，用于保证 **数据的完整性**，实际上也并且并 **没有加密任何数据**。

#### 用于接口调用

接下来在 `API` 调用中就可以附上 `JWT`（通常是在 `HTTP Header` 中）。又因为 `SP` 会与程序 **共享** 一个 `secret`，所以 **程序** 可以通过 `header` 提供的相同的 `hash` 算法来 **验证签名** 是否正确，从而判断应用是否有权力调用 `API`。

### 有状态的对话Session

因为 `HTTP` 是 **无状态** 的，所以 **客户端** 和 **服务端** 需要解决的问题是，如何让它们之间的对话变得有状态。例如只有是 **登陆状态** 的 **用户** 才有权限调用某些接口，那么在 **用户登陆** 之后，需要记住该用户是 **已经登陆** 的状态。常见的方法是使用 `session` 机制。

常见的 `session` 模型是这样工作的：



1. 用户在浏览器 **登陆** 之后，服务端为用户生成 **唯一** 的 `session id`，存储在 **服务端** 的 **存储服务**（例如 `MySQL`, `Redis`）中。
2. 该 `session id` 也同时 **返回给浏览器**，以 `SESSION_ID` 为 `KEY` 存储在浏览器的 `cookie` 中。
3. 如果用户再次访问该网站，`cookie` 里的 `SESSION_ID` 会随着 **请求** 一同发往 **服务端**。
4. 服务端通过判断 `SESSION_ID` 是否已经在 `Redis` 中判断用户是否处于 **登陆状态**。

相信你已经察觉了，理论上来说，`JWT` 机制可以取代 `session` 机制。用户不需要提前进行登陆，后端也不需要 `Redis` 记录用户的登陆信息。客户端的本地保存一份合法的 `JWT`，当用户需要调用接口时，附带上该合法的 `JWT`，每一次调用接口，后端都使用请求中附带的 `JWT` 做一次 **合法性的验证**。这样也间接达到了 **认证用户** 的目的。





# JWT 和session

## session

```
1. 用户输入其登录信息
2. 服务器验证信息是否正确，并创建一个session，然后将其存储在数据库中
3. 服务器为用户生成一个sessionId，将具有sesssionId的Cookie将放置在用户浏览器中
4. 在后续请求中，会根据数据库验证sessionID，如果有效，则接受请求
5. 一旦用户注销应用程序，会话将在客户端和服务器端都被销毁
```

JWT

```
1. 用户输入其登录信息
2. 服务器验证信息是否正确，并返回已签名的token
3. token储在客户端，例如存在local storage或cookie中
4. 之后的HTTP请求都将token添加到请求头里
5. 服务器解码JWT，并且如果令牌有效，则接受请求
6. 一旦用户注销，令牌将在客户端被销毁，不需要与服务器进行交互一个关键是，令牌是无状态的。后端服务器不需要保存令牌或当前session的记录。
```



# 区别和优缺点：

基于session和基于jwt的方式的主要区别就是用户的状态保存的位置，session是保存在服务端的，而jwt是保存在客户端的。

 

### jwt的优点：

1. 可扩展性好

应用程序分布式部署的情况下，session需要做多机数据共享，通常可以存在数据库或者redis里面。而jwt不需要。

2. 无状态

jwt不在服务端存储任何状态。RESTful API的原则之一是无状态，发出请求时，总会返回带有参数的响应，不会产生附加影响。用户的认证状态引入这种附加影响，这破坏了这一原则。另外jwt的载荷中可以存储一些常用信息，用于交换信息，有效地使用 JWT，可以降低服务器查询数据库的次数。

 

### jwt的缺点：

1. 安全性

由于jwt的payload是使用base64编码的，并没有加密，因此jwt中不能存储敏感数据。而session的信息是存在服务端的，相对来说更安全。

2. 性能

jwt太长。由于是无状态使用JWT，所有的数据都被放到JWT里，如果还要进行一些数据交换，那载荷会更大，经过编码之后导致jwt非常长，cookie的限制大小一般是4k，cookie很可能放不下，所以jwt一般放在local storage里面。并且用户在系统中的每一次http请求都会把jwt携带在Header里面，http请求的Header可能比Body还要大。而sessionId只是很短的一个字符串，因此使用jwt的http请求比使用session的开销大得多。

3. 一次性

无状态是jwt的特点，但也导致了这个问题，jwt是一次性的。想修改里面的内容，就必须签发一个新的jwt。

（1）无法废弃

通过上面jwt的验证机制可以看出来，一旦签发一个jwt，在到期之前就会始终有效，无法中途废弃。例如你在payload中存储了一些信息，当信息需要更新时，则重新签发一个jwt，但是由于旧的jwt还没过期，拿着这个旧的jwt依旧可以登录，那登录后服务端从jwt中拿到的信息就是过时的。为了解决这个问题，我们就需要在服务端部署额外的逻辑，例如设置一个黑名单，一旦签发了新的jwt，那么旧的就加入黑名单（比如存到redis里面），避免被再次使用。

（2）续签

如果你使用jwt做会话管理，传统的cookie续签方案一般都是框架自带的，session有效期30分钟，30分钟内如果有访问，有效期被刷新至30分钟。一样的道理，要改变jwt的有效时间，就要签发新的jwt。最简单的一种方式是每次请求刷新jwt，即每个http请求都返回一个新的jwt。这个方法不仅暴力不优雅，而且每次请求都要做jwt的加密解密，会带来性能问题。另一种方法是在redis中单独为每个jwt设置过期时间，每次访问时刷新jwt的过期时间。

 

可以看出想要破解jwt一次性的特性，就需要在服务端存储jwt的状态。但是引入 redis 之后，就把无状态的jwt硬生生变成了有状态了，违背了jwt的初衷。而且这个方案和session都差不多了。



适合使用jwt的场景：

- 有效期短
- 只希望被使用一次

比如，用户注册后发一封邮件让其激活账户，通常邮件中需要有一个链接，这个链接需要具备以下的特性：能够标识用户，该链接具有时效性（通常只允许几小时之内激活），不能被篡改以激活其他可能的账户，一次性的。这种场景就适合使用jwt。

而由于jwt具有一次性的特性。单点登录和会话管理非常不适合用jwt，如果在服务端部署额外的逻辑存储jwt的状态，那还不如使用session。基于session有很多成熟的框架可以开箱即用，但是用jwt还要自己实现逻辑。















拓展：

JSON Web Token (JWT)
JSON Web Signature (JWS)
JSON Web Encryption (JWE)
JSON Web Key (JWK)



参考文章:[零壹技术栈](https://www.jianshu.com/p/ff9d3ad817ca)